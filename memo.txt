ALGORITHM

BASIC LOOP
- loop through the string
- write and count every character until '%' or '\0'
- if '\0' return data.count
- else if '%'
 - check if char after '%' is flag:
 	- if char is flag, increment index
 		- for every found flag insert true in data
 		- QUESTION: Does printf allow the flags to be in any order?
 			- yes until precision -> after precision can only be numbers
 		- QUESTION: Does the flags have to match the specifier or are they just omitted? e.g. can 'c' have a precision or 'p' a '+'?
 			- flags don't have to match. The unmatched flags are omitted.
 - check if the char in current index is specifier
 	- if char is specifier INITIALIZE PRINTING by returning the specifier 
 	- if char is not specifier -> return ERROR

INITIALIZE PRINTING
- check the returned flag and go into appropriate if statement: PUTCHAR, PUTSTR, PUTNBR, PUTADDR

PUTCHAR 'C' FLAGS -> prototype void char_flags(char c, struct data)
- check if width
	- if not width or width <= 1 -> putchar('c', 1, data)
	- else if '-' and width > 1
		- putchar('c', 1, data)
		- putchar(' ', width - 1, data)
	- else
		- putchar(' ', width - 1, data)
		- putchar('c', 1, data)

PUTCHAR -> prototype void putchar(char c, int width, struct data)
while (width--)
	write(1, c, 1) and data.count += 1;

PUTSTR 'S' FLAGS -> prototype str_flags(char *str, struct data)
- initialize len with strlen(str)
- check if precision
	- if not precision or precision >= len -> break
	- if precision < len
		- len = precision
- check if width
	- if not width or width <= len -> putstr(str, len, len, data)
	- else -> putstr(str, len, width, data)
- QUESTION: What if we have large width and small precision?
	- Both are valid. Precision shortens the word but every space of width is used

PUTSTR -> prototype putstr(const char *str, int len, int width, struct data)
data.count += width;
if (left justified)
	while (width-- && len--)
		write (1, str++, 1);
	while (width--)
		write (1, ' ', 1);
else
	while (width-- > len)
		write (1, ' ', 1);
	while (width--)
		write (1, str++, 1);
		
